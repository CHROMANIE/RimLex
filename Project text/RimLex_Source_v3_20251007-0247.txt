RimLex ソース一式＋運用メモ v3
作成: 2025-10-07 02:47 (JST)
バージョン: 0.9.0（MVP確定版）
このファイルの目的： RimLexの「ソース一式＋運用情報」をひとつにまとめた“完全アーカイブ”。
チャット引き継ぎ用に、この1ファイルだけを次のスレッドへ渡せば開発を継続できます。


============================================================
■ フォルダ構成（推奨）
============================================================
<ModRoot>/
  ├─ About/
  │   └─ About.xml
  ├─ Assemblies/
  │   └─ RimLex.dll                    … ビルド成果物
  ├─ Dict/
  │   └─ strings_ja.tsv                … 「英語<TAB>日本語」
  ├─ Export/                           … 実行時に生成
  ├─ Source/
  │   ├─ RimLex.csproj
  │   ├─ Config.cs
  │   ├─ Normalizer.cs
  │   ├─ NoiseFilter.cs
  │   ├─ TranslatorHub.cs
  │   ├─ UIPatches.cs
  │   └─ ModInitializer.cs
  └─ RimLex.ini

============================================================
■ RimLex.csproj
============================================================
<Project ToolsVersion="15.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"
          Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />

  <PropertyGroup>
    <!-- DLL出力 -->
    <OutputType>Library</OutputType>
    <!-- .NET Framework（RimWorld 1.6 / Unity 2022 LTS に最適化） -->
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <TargetFrameworkProfile />
    <!-- 既定は Release / AnyCPU -->
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform>AnyCPU</Platform>

    <!-- この .csproj が Mods/RimLex/Source/ にある前提で Assemblies へ出力 -->
    <OutputPath>..\Assemblies\</OutputPath>
    <BaseIntermediateOutputPath>obj\</BaseIntermediateOutputPath>

    <!-- ビルドオプション -->
    <Optimize>true</Optimize>
    <LangVersion>latest</LangVersion>
    <WarningLevel>4</WarningLevel>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>

    <!-- アセンブリ名とルート名前空間 -->
    <AssemblyName>RimLex</AssemblyName>
    <RootNamespace>RimLex</RootNamespace>

    <!-- RimWorld ルート推定（この .csproj が Mods/RimLex/Source/ にある前提） -->
    <RimWorldRoot>$(SolutionDir)..\..\</RimWorldRoot>
    <ManagedDir>$(RimWorldRoot)RimWorldWin64_Data\Managed\</ManagedDir>
    <!-- Harmony は Mods/Harmony を基準に統一 -->
    <HarmonyDll>$(RimWorldRoot)Mods\Harmony\Assemblies\0Harmony.dll</HarmonyDll>

    <!-- プロジェクト GUID（任意） -->
    <ProjectGuid>{A82101D6-A1A1-4049-B7FA-D57CE057277E}</ProjectGuid>
  </PropertyGroup>

  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <Optimize>false</Optimize>
    <DefineConstants>TRACE;DEBUG</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <Optimize>true</Optimize>
    <DefineConstants>TRACE</DefineConstants>
  </PropertyGroup>

  <ItemGroup>
    <!-- ゲーム本体 / Unity 参照 -->
    <Reference Include="Assembly-CSharp">
      <HintPath>$(ManagedDir)Assembly-CSharp.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>$(ManagedDir)UnityEngine.CoreModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>$(ManagedDir)UnityEngine.IMGUIModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule">
      <HintPath>$(ManagedDir)UnityEngine.TextRenderingModule.dll</HintPath>
      <Private>false</Private>
    </Reference>

    <!-- Harmony（Mods/Harmony を基準に） -->
    <Reference Include="0Harmony">
      <HintPath>$(HarmonyDll)</HintPath>
      <Private>false</Private>
    </Reference>

    <!-- .NET 標準 -->
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
  </ItemGroup>

  <ItemGroup>
    <!-- この .csproj が Source/ にある前提の相対パス -->
    <Compile Include="Config.cs" />
    <Compile Include="MenuUI.cs" />
    <Compile Include="ModInitializer.cs" />
    <Compile Include="NoiseFilter.cs" />
    <Compile Include="Normalizer.cs" />
    <Compile Include="TranslatorHub.cs" />
    <Compile Include="UIPatches.cs" />
    <Compile Include="UTFBuilder.cs" />
  </ItemGroup>

  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

============================================================
■ Config.cs
============================================================
using System;
using System.IO;
using System.Text;

namespace RimLex
{
    public class Config
    {
        public bool   ApplyDictAtRuntime = true;
        public string DictTsv;
        public string ExportRoot;
        public bool   ExportPerMod = true;
        public bool   EmitAggregate = true;
        public string ExportMode = "Both";
        public string PerModSubdir = "PerMod";
        public int    MinLength = 2;
        public string ExcludePatterns =
            @"^\s*$|^https?://|^[0-9]+$|^\d+(\.\d+)+$|^[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$|^\p{Zs}+$|^\p{Cc}+$";

        public string LogPath;
        private string _iniPath;

        public static Config Load(string iniPath, string defaultDict, string defaultLog, string defaultExportRoot)
        {
            var c = new Config();
            c._iniPath   = iniPath;
            c.DictTsv    = defaultDict;
            c.LogPath    = defaultLog;
            c.ExportRoot = defaultExportRoot;

            try
            {
                if (File.Exists(iniPath))
                {
                    foreach (var raw in File.ReadAllLines(iniPath, new UTF8Encoding(false)))
                    {
                        var line = raw.Trim();
                        if (line.Length == 0 || line.StartsWith("#") || line.StartsWith(";")) continue;
                        int eq = line.IndexOf('=');
                        if (eq <= 0) continue;

                        string k = line.Substring(0, eq).Trim();
                        string v = line.Substring(eq + 1).Trim();

                        switch (k)
                        {
                            case "ApplyDictAtRuntime": c.ApplyDictAtRuntime = ParseBool(v, c.ApplyDictAtRuntime); break;
                            case "ExportPerMod":       c.ExportPerMod       = ParseBool(v, c.ExportPerMod); break;
                            case "EmitAggregate":      c.EmitAggregate      = ParseBool(v, c.EmitAggregate); break;
                            case "ExportMode":         c.ExportMode         = string.IsNullOrWhiteSpace(v) ? c.ExportMode : v; break;
                            case "PerModSubdir":       c.PerModSubdir       = string.IsNullOrWhiteSpace(v) ? c.PerModSubdir : v; break;
                            case "MinLength":          c.MinLength          = TryInt(v, c.MinLength); break;
                            case "ExcludePatterns":    c.ExcludePatterns    = string.IsNullOrWhiteSpace(v) ? c.ExcludePatterns : v; break;

                            case "DictPath":           c.DictTsv            = Resolve(v, c.DictTsv); break;
                            case "LogPath":            c.LogPath            = Resolve(v, c.LogPath); break;
                            case "ExportRoot":         c.ExportRoot         = Resolve(v, c.ExportRoot); break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Verse.Log.Warning("[RimLex] ini load failed: " + ex.Message);
            }

            return c;
        }

        public void Save()
        {
            try
            {
                var sb = new StringBuilder();
                sb.AppendLine("# RimLex settings");
                sb.AppendLine("ApplyDictAtRuntime=" + (ApplyDictAtRuntime ? "true" : "false"));
                sb.AppendLine("ExportPerMod=" + (ExportPerMod ? "true" : "false"));
                sb.AppendLine("EmitAggregate=" + (EmitAggregate ? "true" : "false"));
                sb.AppendLine("ExportMode=" + ExportMode);
                sb.AppendLine("DictPath=" + ToIni(DictTsv));
                sb.AppendLine("LogPath=" + ToIni(LogPath));
                sb.AppendLine("ExportRoot=" + ToIni(ExportRoot));
                sb.AppendLine("PerModSubdir=" + (string.IsNullOrWhiteSpace(PerModSubdir) ? "PerMod" : PerModSubdir));
                sb.AppendLine("MinLength=" + MinLength);
                sb.AppendLine("ExcludePatterns=" + ExcludePatterns);
                File.WriteAllText(_iniPath, sb.ToString(), new UTF8Encoding(false));
            }
            catch (Exception ex)
            {
                Verse.Log.Warning("[RimLex] ini save failed: " + ex.Message);
            }
        }

        private static bool ParseBool(string v, bool def) =>
            v.Equals("true", StringComparison.OrdinalIgnoreCase) || v == "1"
                ? true
                : (v.Equals("false", StringComparison.OrdinalIgnoreCase) || v == "0" ? false : def);

        private static int TryInt(string v, int def)
        {
            if (int.TryParse(v, out var n)) return n;
            return def;
        }

        private static string Resolve(string v, string def)
        {
            if (string.IsNullOrWhiteSpace(v)) return def;
            return v.Replace("%ModDir%", ModInitializer.ModDir ?? "").Replace('\\', '/');
        }

        private static string ToIni(string abs)
        {
            try
            {
                var md = (ModInitializer.ModDir ?? "").Replace('\\', '/');
                var a  = (abs ?? "").Replace('\\', '/');
                if (!string.IsNullOrEmpty(md) && a.StartsWith(md, StringComparison.OrdinalIgnoreCase))
                    return "%ModDir%" + a.Substring(md.Length);
            }
            catch { }
            return abs ?? "";
        }
    }
}

============================================================
■ Normalizer.cs
============================================================
using System.Text.RegularExpressions;

namespace RimLex
{
    public static class Normalizer
    {
        private static readonly Regex RxTags = new Regex(
            @"<\/?(?:color(?:=[^>]*)?|size(?:=[^>]*)?|b|i|u|align(?:=[^>]*)?|br)\s*>",
            RegexOptions.IgnoreCase | RegexOptions.Compiled);

        private static readonly Regex RxCtrl = new Regex(@"[\u0000-\u001F]", RegexOptions.Compiled);
        private static readonly Regex RxSpaces = new Regex(@"\s{2,}", RegexOptions.Compiled);

        public static string Normalize(string s)
        {
            if (string.IsNullOrEmpty(s)) return string.Empty;
            var t = s.Replace("\r\n", "\n").Replace("\r", "\n");
            t = RxTags.Replace(t, string.Empty);
            t = RxCtrl.Replace(t, string.Empty);
            t = t.Replace('\n', ' ');
            t = RxSpaces.Replace(t, " ");
            return t.Trim();
        }
    }
}

============================================================
■ NoiseFilter.cs
============================================================
using System.Text.RegularExpressions;

namespace RimLex
{
    public static class NoiseFilter
    {
        private static int _minLen = 2;
        private static Regex[] _rx = new Regex[0];

        public static void Init(Config cfg)
        {
            _minLen = cfg.MinLength > 0 ? cfg.MinLength : 2;
            var parts = (cfg.ExcludePatterns ?? "").Split('|');
            _rx = new Regex[parts.Length];
            for (int i = 0; i < parts.Length; i++)
            {
                var p = parts[i].Trim();
                if (p.Length == 0) p = "$a"; // match nothing
                _rx[i] = new Regex(p, RegexOptions.IgnoreCase | RegexOptions.Compiled);
            }
        }

        public static bool IsNoise(string s)
        {
            if (string.IsNullOrEmpty(s)) return true;
            if (s.Length < _minLen) return true;
            for (int i = 0; i < _rx.Length; i++)
            {
                if (_rx[i].IsMatch(s)) return true;
            }
            return false;
        }
    }
}

============================================================
■ TranslatorHub.cs
============================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace RimLex
{
    public static class TranslatorHub
    {
        // 辞書
        private static readonly Dictionary<string, string> _ja = new Dictionary<string, string>(StringComparer.Ordinal);
        public  static int DictionaryEntryCount => _ja.Count;

        // 設定
        private static string _dictPath = "";
        private static string _exportRoot = "";
        private static string _exportMode = "Both";
        private static bool   _exportPerMod = true;
        private static bool   _emitAggregate = true;
        private static string _perModSubdir = "PerMod";

        // ログ
        private static Action<string> _logInfo = _ => { };
        private static Action<string> _logWarn = _ => { };

        // セッション重複抑止
        private static readonly HashSet<string> _sessionPerMod = new HashSet<string>(StringComparer.Ordinal);
        private static readonly HashSet<string> _sessionAgg    = new HashSet<string>(StringComparer.Ordinal);

        // 統計
        private static int _replaced = 0, _collected = 0, _ioErrors = 0;

        // ヘッダ定数
        private const string TSV_HEADER = "timestamp_utc\tmod\tsource\tscope\ttext";

        public static void InitIO(
            string dictPath,
            string exportRoot,
            string exportMode,
            bool exportPerMod,
            bool emitAggregate,
            Action<string> logInfo,
            Action<string> logWarn,
            string perModSubdir
        )
        {
            _dictPath      = dictPath ?? "";
            _exportRoot    = exportRoot ?? "";
            _exportMode    = string.IsNullOrWhiteSpace(exportMode) ? "Both" : exportMode;
            _exportPerMod  = exportPerMod;
            _emitAggregate = emitAggregate;
            _perModSubdir  = string.IsNullOrWhiteSpace(perModSubdir) ? "PerMod" : perModSubdir;
            _logInfo = logInfo ?? (_ => { });
            _logWarn = logWarn ?? (_ => { });

            Directory.CreateDirectory(_exportRoot);

            ReloadDictionary();

            _sessionPerMod.Clear();
            _sessionAgg.Clear();
            _replaced = _collected = _ioErrors = 0;

            // _All 軽量追記用のフォルダ
            if (_emitAggregate)
                Directory.CreateDirectory(Path.Combine(_exportRoot, "_All"));
        }

        public static void ReloadDictionary()
        {
            _ja.Clear();
            try
            {
                if (File.Exists(_dictPath))
                {
                    foreach (var line in File.ReadAllLines(_dictPath, new UTF8Encoding(false)))
                    {
                        if (string.IsNullOrWhiteSpace(line)) continue;
                        var sp = line.Split('\t');
                        if (sp.Length >= 2)
                        {
                            var en = Normalizer.Normalize(sp[0]);
                            var ja = sp[1].Trim();
                            if (!_ja.ContainsKey(en)) _ja[en] = ja;
                        }
                    }
                    _logInfo("Dict loaded: " + _ja.Count + " entries.");
                }
                else
                {
                    _logInfo("Dict not found (skip).");
                }
            }
            catch (Exception ex)
            {
                _logWarn("Dict load failed: " + ex.Message);
            }
        }

        public static string TranslateOrEnroll(string text, string source, string scope)
        {
            if (string.IsNullOrWhiteSpace(text)) return text;

            string norm = Normalizer.Normalize(text);
            if (_ja.TryGetValue(norm, out var ja))
            {
                _replaced++;
                return ja;
            }

            if (NoiseFilter.IsNoise(norm)) return text;

            Enroll(norm, source, scope);
            return text;
        }

        private static void Enroll(string en, string source, string scope)
        {
            try
            {
                var modName = ResolveCallingModName();
                string perModDir = _exportPerMod
                    ? Path.Combine(_exportRoot, _perModSubdir, modName)
                    : Path.Combine(_exportRoot, "Current");

                Directory.CreateDirectory(perModDir);
                var utf8 = new UTF8Encoding(false);

                // strings_en.tsv
                if (_exportMode.Equals("Full", StringComparison.OrdinalIgnoreCase) ||
                    _exportMode.Equals("Both", StringComparison.OrdinalIgnoreCase))
                {
                    string tsv = Path.Combine(perModDir, "strings_en.tsv");
                    EnsureTsvHeader(tsv);
                    File.AppendAllText(tsv,
                        $"{DateTime.UtcNow:O}\t{modName}\t{source ?? "UI"}\t{scope ?? "UI"}\t{en}\n", utf8);
                }

                // texts_en.txt
                if (_exportMode.Equals("TextOnly", StringComparison.OrdinalIgnoreCase) ||
                    _exportMode.Equals("Both", StringComparison.OrdinalIgnoreCase))
                {
                    string txt = Path.Combine(perModDir, "texts_en.txt");
                    // 同一セッションでの重複抑止
                    if (_sessionPerMod.Add($"{modName}::{en}"))
                        File.AppendAllText(txt, en + "\n", utf8);
                }

                // _All 軽量追記
                if (_emitAggregate)
                    TryEnsureAggregateLazy(en);

                _collected++;
            }
            catch (Exception ex)
            {
                _ioErrors++;
                _logWarn("Enroll failed: " + ex.Message);
            }
        }

        private static void EnsureTsvHeader(string path)
        {
            try
            {
                if (!File.Exists(path))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(path) ?? _exportRoot);
                    File.WriteAllText(path, TSV_HEADER + "\n", new UTF8Encoding(false));
                }
                else if (new FileInfo(path).Length == 0)
                {
                    File.WriteAllText(path, TSV_HEADER + "\n", new UTF8Encoding(false));
                }
            }
            catch (Exception ex)
            {
                _ioErrors++;
                _logWarn("Header write failed: " + ex.Message);
            }
        }

        public static void TryEnsureAggregateLazy(string en)
        {
            try
            {
                if (!_emitAggregate) return;

                var allDir = Path.Combine(_exportRoot, "_All");
                Directory.CreateDirectory(allDir);
                string agg = Path.Combine(allDir, "texts_en_aggregate.txt");

                if (_sessionAgg.Add(en))
                    File.AppendAllText(agg, en + "\n", new UTF8Encoding(false));
            }
            catch (Exception ex)
            {
                _ioErrors++;
                _logWarn("Aggregate lazy failed: " + ex.Message);
            }
        }

        public static void RebuildAggregateAndUntranslated(out int aggCount, out int untransCount, out int modSections)
        {
            aggCount = untransCount = modSections = 0;
            try
            {
                var all = new SortedSet<string>(StringComparer.Ordinal);

                // 旧レイアウト（Export/<Mod>）も拾う
                var perModRoot = Path.Combine(_exportRoot, _perModSubdir);
                var legacyRoots = new List<string> { _exportRoot };
                if (Directory.Exists(perModRoot)) legacyRoots.Add(perModRoot);

                // Per-Mod 収集
                var perModDirs = new List<string>();
                if (Directory.Exists(perModRoot))
                    perModDirs.AddRange(Directory.GetDirectories(perModRoot));

                // 直下の旧レイアウト（_All/Current/PerMod 以外）
                foreach (var d in Directory.GetDirectories(_exportRoot))
                {
                    var name = Path.GetFileName(d);
                    if (string.Equals(name, "_All", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(name, "Current", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(name, _perModSubdir, StringComparison.OrdinalIgnoreCase)) continue;
                    perModDirs.Add(d);
                }

                // texts_en.txt を集めて ALL を構築
                foreach (var dir in perModDirs)
                {
                    string txt = Path.Combine(dir, "texts_en.txt");
                    if (!File.Exists(txt)) continue;
                    foreach (var line in File.ReadAllLines(txt, new UTF8Encoding(false)))
                    {
                        var s = line.Trim();
                        if (s.Length == 0) continue;
                        all.Add(s);
                    }
                }

                Directory.CreateDirectory(Path.Combine(_exportRoot, "_All"));
                string allTxt = Path.Combine(_exportRoot, "_All", "texts_en_aggregate.txt");
                File.WriteAllLines(allTxt, all, new UTF8Encoding(false));
                aggCount = all.Count;

                // 未訳抽出
                var untranslated = all.Where(s => !_ja.ContainsKey(Normalizer.Normalize(s))).ToList();
                string unTxt = Path.Combine(_exportRoot, "_All", "untranslated.txt");
                File.WriteAllLines(unTxt, untranslated, new UTF8Encoding(false));
                untransCount = untranslated.Count;

                // 1列TSV
                string tsv = Path.Combine(_exportRoot, "_All", "strings_en_aggregate.tsv");
                var tsvLines = new List<string>(untranslated.Count + 1) { "text" };
                tsvLines.AddRange(untranslated);
                File.WriteAllLines(tsv, tsvLines, new UTF8Encoding(false));

                // Mod別グルーピング
                var sb = new StringBuilder(1024);
                var groups = new SortedDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
                foreach (var dir in perModDirs)
                {
                    var mod = Path.GetFileName(dir);
                    string txt = Path.Combine(dir, "texts_en.txt");
                    if (!File.Exists(txt)) continue;
                    groups[mod] = File.ReadAllLines(txt, new UTF8Encoding(false))
                        .Select(s => s.Trim()).Where(s => s.Length > 0).Distinct().OrderBy(s => s, StringComparer.Ordinal).ToList();
                }
                foreach (var kv in groups)
                {
                    sb.AppendLine($"### {kv.Key} ({kv.Value.Count})");
                    foreach (var s in kv.Value) sb.AppendLine(s);
                    sb.AppendLine(); // 空行 ×2（可読性）
                    sb.AppendLine();
                }
                File.WriteAllText(Path.Combine(_exportRoot, "_All", "grouped_by_mod.txt"), sb.ToString(), new UTF8Encoding(false));
                modSections = groups.Count;

                _logInfo($"Aggregate rebuilt: all={aggCount}, untranslated={untransCount}, mods={modSections}");
            }
            catch (Exception ex)
            {
                _ioErrors++;
                _logWarn("Rebuild aggregate failed: " + ex);
            }
        }

        public static bool TryResetExport(out string error)
        {
            error = null;
            try
            {
                if (Directory.Exists(_exportRoot))
                    Directory.Delete(_exportRoot, true);
                Directory.CreateDirectory(_exportRoot);
                return true;
            }
            catch (Exception ex)
            {
                error = ex.Message;
                _ioErrors++;
                return false;
            }
        }

        public static void ClearSessionCaches(out int perMod, out int aggregate)
        {
            perMod = _sessionPerMod.Count;
            aggregate = _sessionAgg.Count;
            _sessionPerMod.Clear();
            _sessionAgg.Clear();
        }

        public static void GetAndResetSessionStats(out int replaced, out int collected, out int ioErrors)
        {
            replaced = _replaced; collected = _collected; ioErrors = _ioErrors;
            _replaced = _collected = _ioErrors = 0;
        }

        // 呼び出しMod名の推定（Mods/<ModName>/… をStackTraceから逆引き）
        public static string ResolveCallingModName()
        {
            try
            {
                var st = new StackTrace(2, false);
                for (int i = 0; i < st.FrameCount; i++)
                {
                    var m = st.GetFrame(i).GetMethod();
                    var t = m?.DeclaringType;
                    var asm = t?.Assembly;
                    if (asm == null) continue;

                    var name = asm.GetName().Name ?? "";
                    // 除外: ベース/ランタイム/自分
                    if (name.StartsWith("RimLex")) continue;
                    if (name.StartsWith("Assembly-CSharp")) continue;
                    if (name.StartsWith("UnityEngine")) continue;
                    if (name.StartsWith("System")) continue;
                    if (name.StartsWith("mscorlib")) continue;
                    if (name.StartsWith("0Harmony")) continue;

                    var loc = "";
                    try { loc = asm.Location?.Replace('\\', '/'); } catch { }
                    if (!string.IsNullOrEmpty(loc))
                    {
                        var idx = loc.IndexOf("/Mods/", StringComparison.OrdinalIgnoreCase);
                        if (idx >= 0)
                        {
                            var tail = loc.Substring(idx + "/Mods/".Length);
                            var first = tail.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
                            if (!string.IsNullOrEmpty(first))
                                return first;
                        }
                    }
                    // ロケーション不明ならアセンブリ名を返す
                    if (!string.IsNullOrEmpty(name)) return name;
                }
            }
            catch { }
            return "RimWorld"; // フォールバック
        }
    }
}

============================================================
■ UIPatches.cs
============================================================
using System;
using System.Linq;
using System.Reflection;
using HarmonyLib;
using RimWorld;
using UnityEngine;
using Verse;

namespace RimLex
{
    [StaticConstructorOnStartup]
    public static class UIPatches
    {
        private static bool _applyAtRuntime;

        public static void Apply(Harmony harmony, Action<string> logInfo, Action<string> logWarn, bool applyAtRuntime)
        {
            _applyAtRuntime = applyAtRuntime;

            void Try(Action a) { try { a(); } catch (Exception ex) { logWarn?.Invoke("Patch step failed: " + ex.Message); } }

            // Widgets.Label(Rect,string)
            Try(() =>
            {
                var m = typeof(Widgets).GetMethods(BindingFlags.Public | BindingFlags.Static)
                    .FirstOrDefault(mi =>
                    {
                        if (mi.Name != nameof(Widgets.Label)) return false;
                        var ps = mi.GetParameters();
                        return ps.Length == 2 && ps[0].ParameterType == typeof(Rect) && ps[1].ParameterType == typeof(string);
                    });
                if (m != null)
                {
                    harmony.Patch(m, prefix: new HarmonyMethod(typeof(UIPatches), nameof(Widgets_Label_Prefix)));
                    logInfo?.Invoke("Patched: Widgets.Label(Rect,string)");
                }
                else logWarn?.Invoke("Patch skip: Widgets.Label not found");
            });

            // Listing_Standard.Label(*, 第1引数string)
            Try(() =>
            {
                var targets = typeof(Listing_Standard).GetMethods(BindingFlags.Public | BindingFlags.Instance)
                    .Where(mi => mi.Name == "Label" && mi.GetParameters().Length >= 1 && mi.GetParameters()[0].ParameterType == typeof(string))
                    .ToArray();
                foreach (var t in targets)
                    harmony.Patch(t, prefix: new HarmonyMethod(typeof(UIPatches), nameof(Listing_Label_Generic_Prefix)));
                if (targets.Length > 0) logInfo?.Invoke($"Patched: Listing_Standard.Label x{targets.Length}");
            });

            // Widgets.ButtonText(Rect,string,…)
            Try(() =>
            {
                var target = typeof(Widgets).GetMethods(BindingFlags.Public | BindingFlags.Static)
                    .Where(mi => mi.Name == "ButtonText")
                    .FirstOrDefault(mi =>
                    {
                        var ps = mi.GetParameters();
                        return ps.Length >= 2 && ps[0].ParameterType == typeof(Rect) && ps[1].ParameterType == typeof(string);
                    });
                if (target != null)
                {
                    harmony.Patch(target, prefix: new HarmonyMethod(typeof(UIPatches), nameof(ButtonText_Prefix)));
                    logInfo?.Invoke("Patched: Widgets.ButtonText");
                }
                else logWarn?.Invoke("Patch skip: Widgets.ButtonText not found");
            });

            // Slider（署名差異でも例外を出さない）
            Try(() =>
            {
                var slider = AccessTools.Method(typeof(Listing_Standard), "Slider", new[] { typeof(float), typeof(float), typeof(float) });
                if (slider != null)
                {
                    harmony.Patch(slider, prefix: new HarmonyMethod(typeof(UIPatches), nameof(Slider_Prefix)));
                    logInfo?.Invoke("Patched: Listing_Standard.Slider");
                }
                else logWarn?.Invoke("Patch skip: Listing_Standard.Slider not found");
            });

            // TooltipHandler.TipRegion(Rect,string) 全Overload
            Try(() =>
            {
                var tipStrMethods = typeof(TooltipHandler).GetMethods(BindingFlags.Public | BindingFlags.Static)
                    .Where(mi => mi.Name == "TipRegion")
                    .Where(mi =>
                    {
                        var ps = mi.GetParameters();
                        return ps.Length == 2 && ps[0].ParameterType == typeof(Rect) && ps[1].ParameterType == typeof(string);
                    })
                    .ToArray();
                foreach (var m in tipStrMethods)
                    harmony.Patch(m, prefix: new HarmonyMethod(typeof(UIPatches), nameof(Tooltip_String_Prefix)));
                if (tipStrMethods.Length > 0)
                    logInfo?.Invoke($"Patched: TooltipHandler.TipRegion(Rect,string) x{tipStrMethods.Length}");
            });

            // TooltipHandler.TipRegion(Rect,TipSignal)
            Try(() =>
            {
                var m = typeof(TooltipHandler).GetMethods(BindingFlags.Public | BindingFlags.Static)
                    .FirstOrDefault(mi =>
                    {
                        if (mi.Name != "TipRegion") return false;
                        var ps = mi.GetParameters();
                        return ps.Length == 2 && ps[0].ParameterType == typeof(Rect) && ps[1].ParameterType == typeof(TipSignal);
                    });
                if (m != null)
                {
                    harmony.Patch(m, prefix: new HarmonyMethod(typeof(UIPatches), nameof(Tooltip_Signal_Prefix)));
                    logInfo?.Invoke("Patched: TooltipHandler.TipRegion(Rect,TipSignal)");
                }
                else logWarn?.Invoke("Patch skip: TooltipHandler.TipRegion(Rect,TipSignal) not found");
            });

            // FloatMenuOption::.ctor(string,Action,…)
            Try(() =>
            {
                var ctor = typeof(FloatMenuOption).GetConstructors(BindingFlags.Public | BindingFlags.Instance)
                    .FirstOrDefault(ci =>
                    {
                        var ps = ci.GetParameters();
                        return ps.Length >= 2 && ps[0].ParameterType == typeof(string) && ps[1].ParameterType == typeof(Action);
                    });
                if (ctor != null)
                {
                    harmony.Patch(ctor, prefix: new HarmonyMethod(typeof(UIPatches), nameof(FloatMenuOption_Ctor_Prefix)));
                    logInfo?.Invoke("Patched: FloatMenuOption::.ctor");
                }
                else logWarn?.Invoke("Patch skip: FloatMenuOption ctor not found");
            });

            // Command.LabelCap.get
            Try(() =>
            {
                var getter = AccessTools.PropertyGetter(typeof(Command), nameof(Command.LabelCap));
                if (getter != null)
                {
                    harmony.Patch(getter, postfix: new HarmonyMethod(typeof(UIPatches), nameof(Command_LabelCap_Postfix)));
                    logInfo?.Invoke("Patched: Command.LabelCap.get");
                }
                else logWarn?.Invoke("Patch skip: Command.LabelCap.get not found");
            });

            logInfo?.Invoke($"UIPatches applied. ApplyDictAtRuntime={_applyAtRuntime}");
        }

        // ----- Prefixes / Postfixes -----
        public static bool Widgets_Label_Prefix(Rect rect, ref string label)
        {
            if (string.IsNullOrEmpty(label)) return true;
            var ja = TranslatorHub.TranslateOrEnroll(label, "Widgets.Label", "UI");
            if (_applyAtRuntime) label = ja;
            return true;
        }

        // 第1引数 string だけ受ける汎用プレフィックス
        public static bool Listing_Label_Generic_Prefix(ref string __0)
        {
            if (string.IsNullOrEmpty(__0)) return true;
            var ja = TranslatorHub.TranslateOrEnroll(__0, "Listing_Standard.Label", "UI");
            if (_applyAtRuntime) __0 = ja;
            return true;
        }

        public static bool ButtonText_Prefix(Rect rect, ref string __1)
        {
            if (string.IsNullOrEmpty(__1)) return true;
            var ja = TranslatorHub.TranslateOrEnroll(__1, "Widgets.ButtonText", "UI");
            if (_applyAtRuntime) __1 = ja;
            return true;
        }

        public static bool Slider_Prefix(float val, float min, float max) => true;

        public static bool Tooltip_String_Prefix(Rect rect, ref string text)
        {
            if (string.IsNullOrEmpty(text)) return true;
            try
            {
                var ja = TranslatorHub.TranslateOrEnroll(text, "TooltipHandler.TipRegion", "Tooltip");
                if (_applyAtRuntime) text = ja;
            }
            catch { }
            return true;
        }

        public static bool Tooltip_Signal_Prefix(Rect rect, ref TipSignal tip)
        {
            try
            {
                var t = tip.text;
                if (!string.IsNullOrEmpty(t))
                {
                    var ja = TranslatorHub.TranslateOrEnroll(t, "TooltipHandler.TipRegion", "Tooltip");
                    if (_applyAtRuntime) tip = new TipSignal(ja, tip.delay);
                }
            }
            catch { }
            return true;
        }

        public static bool FloatMenuOption_Ctor_Prefix(ref string label)
        {
            if (string.IsNullOrEmpty(label)) return true;
            var ja = TranslatorHub.TranslateOrEnroll(label, "FloatMenuOption", "Context");
            if (_applyAtRuntime) label = ja;
            return true;
        }

        public static void Command_LabelCap_Postfix(ref string __result)
        {
            if (string.IsNullOrEmpty(__result)) return;
            var ja = TranslatorHub.TranslateOrEnroll(__result, "Command.Label", "Gizmo");
            if (_applyAtRuntime) __result = ja;
        }
    }
}

============================================================
■ ModInitializer.cs（設定UIを内蔵）
============================================================
using System;
using System.IO;
using HarmonyLib;
using RimWorld;
using UnityEngine;
using Verse;

namespace RimLex
{
    public class ModInitializer : Mod
    {
        public static readonly string ModId = "com.rimlex";
        public static string ModDir;
        private static System.IO.StreamWriter _log;
        private static Config _cfg;

        public ModInitializer(ModContentPack content) : base(content)
        {
            try
            {
                ModDir = content.RootDir;

                string iniPath   = Path.Combine(ModDir, "RimLex.ini");
                string dictPath  = Path.Combine(ModDir, "Dict", "strings_ja.tsv");
                string logPath   = Path.Combine(ModDir, "RimLex.log");
                string exportDir = Path.Combine(ModDir, "Export");

                _cfg = Config.Load(iniPath, dictPath, logPath, exportDir);

                // ファイルログ初期化
                try
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(_cfg.LogPath) ?? ModDir);
                    _log = new System.IO.StreamWriter(_cfg.LogPath, true, new System.Text.UTF8Encoding(false)) { AutoFlush = true };
                }
                catch (Exception ex)
                {
                    Log.Warning("[RimLex] File log init failed: " + ex.Message);
                    _log = null;
                }

                LogInfo("=== RimLex initializing ===");
                try { Directory.CreateDirectory(_cfg.ExportRoot); } catch { }

                NoiseFilter.Init(_cfg);

                TranslatorHub.InitIO(
                    _cfg.DictTsv,
                    _cfg.ExportRoot,
                    _cfg.ExportMode,
                    _cfg.ExportPerMod,
                    _cfg.EmitAggregate,
                    LogInfo, LogWarn,
                    _cfg.PerModSubdir
                );

                var harmony = new Harmony(ModId);
                UIPatches.Apply(harmony, LogInfo, LogWarn, _cfg.ApplyDictAtRuntime);

                LogInfo("Options: Apply=" + _cfg.ApplyDictAtRuntime +
                        ", PerMod=" + _cfg.ExportPerMod +
                        ", Aggregate=" + _cfg.EmitAggregate +
                        ", Mode=" + _cfg.ExportMode +
                        ", PerModSubdir=" + _cfg.PerModSubdir +
                        ", MinLen=" + _cfg.MinLength);

                LogInfo("=== RimLex initialized ===");
            }
            catch (Exception ex)
            {
                LogWarn("Initialization error: " + ex);
            }
        }

        public override string SettingsCategory() => "RimLex - UI Text Localizer";

        public override void DoSettingsWindowContents(Rect inRect)
        {
            var ls = new Listing_Standard();
            ls.Begin(inRect);

            ls.Label($"辞書: {TranslatorHub.DictionaryEntryCount} 行 / 出力先: {_cfg.ExportRoot}");
            ls.GapLine();

            CheckboxWithTip(ls, "即時反映を有効化（ApplyDictAtRuntime）",
                "ONにすると辞書ヒット時にその場で日本語表示に置き換えます。OFFのときは収集のみを行います。",
                ref _cfg.ApplyDictAtRuntime);

            CheckboxWithTip(ls, "Per-Modに分割して出力（ExportPerMod）",
                $"ON: Export/{_cfg.PerModSubdir}/<Mod名>/ に書き分けます。OFF: Export/Current/ に一括出力します。",
                ref _cfg.ExportPerMod);

            CheckboxWithTip(ls, "_All に統合出力する（EmitAggregate）",
                "ON: 収集中に Export/_All/texts_en_aggregate.txt に軽量追記します。整理ボタンで正式再生成します。",
                ref _cfg.EmitAggregate);

            DrawEnumDropdown(ls, "ExportMode",
                "TextOnly: texts_en.txt のみ / Full: strings_en.tsv のみ / Both: 両方に出力します。",
                new string[] { "TextOnly", "Full", "Both" }, _cfg.ExportMode, v => _cfg.ExportMode = v);

            // PerMod サブディレクトリ名
            Rect rSub = ls.GetRect(30f);
            Widgets.Label(rSub.LeftHalf(), "PerModSubdir： " + _cfg.PerModSubdir);
            if (Widgets.ButtonText(rSub.RightHalf(), "変更"))
            {
                var opts = new System.Collections.Generic.List<FloatMenuOption>
                {
                    new FloatMenuOption("PerMod", () => _cfg.PerModSubdir = "PerMod"),
                    new FloatMenuOption("Mods",   () => _cfg.PerModSubdir = "Mods"),
                    new FloatMenuOption("ByMod",  () => _cfg.PerModSubdir = "ByMod")
                };
                Find.WindowStack.Add(new FloatMenu(opts));
            }
            TooltipHandler.TipRegion(rSub, "Per-Mod のフォルダをまとめる下位フォルダ名です。既存の旧レイアウトも自動で読み取ります。");

            if (DrawButton(ls, "設定を保存", "RimLex.ini に現在の設定を保存します。次回起動時もこの値が使われます。"))
            {
                TryMenuAction("Save ini", () =>
                {
                    _cfg.Save();
                    Messages.Message("設定を保存しました。", MessageTypeDefOf.TaskCompletion, false);
                });
            }

            ls.GapLine();

            if (DrawButton(ls, "未訳一覧を生成",
                "Export/_All/untranslated.txt（辞書未登録のみ）と\nExport/_All/strings_en_aggregate.tsv（表形式）を再生成します。"))
            {
                TryMenuAction("Build untranslated", () =>
                {
                    TranslatorHub.RebuildAggregateAndUntranslated(out var agg, out var untrans, out var mods);
                    Messages.Message($"未訳 {untrans} 行 / 集約 {agg} 行 / Mod別 {mods} セクションを出力しました。", MessageTypeDefOf.TaskCompletion, false);
                });
            }

            if (DrawButton(ls, "整理（MOD別/集約）を生成",
                "Export/_All/grouped_by_mod.txt（### Modごとの一覧）と\nExport/_All/texts_en_aggregate.txt（全体集約）を再構築します。"))
            {
                TryMenuAction("Rebuild aggregate", () =>
                {
                    TranslatorHub.RebuildAggregateAndUntranslated(out var agg, out var untrans, out var mods);
                    Messages.Message($"集約 {agg} 行 / 未訳 {untrans} 行 / Mod別 {mods} セクションを再構築しました。", MessageTypeDefOf.TaskCompletion, false);
                });
            }

            ls.GapLine();
            if (DrawButton(ls, "フォルダを開く：_All", "Export/_All フォルダを開きます。"))
                OpenFolder(Path.Combine(_cfg.ExportRoot, "_All"));
            if (DrawButton(ls, "フォルダを開く：PerMod", $"Export/{_cfg.PerModSubdir} フォルダ（各Modの収集先）を開きます。"))
                OpenFolder(Path.Combine(_cfg.ExportRoot, _cfg.PerModSubdir));
            if (DrawButton(ls, "フォルダを開く：Export", "Export ルートフォルダを開きます。"))
                OpenFolder(_cfg.ExportRoot);

            ls.GapLine();

            if (DrawButton(ls, "収集をリセット",
                "Export フォルダを空にして再作成します。全MODの収集履歴が消えます（辞書には影響しません）。"))
            {
                TryMenuAction("Export reset", () =>
                {
                    if (TranslatorHub.TryResetExport(out var err))
                    {
                        TranslatorHub.ClearSessionCaches(out var pm, out var ag);
                        Messages.Message($"Export を初期化しました（キャッシュ: perMod {pm} / aggregate {ag} クリア）。", MessageTypeDefOf.TaskCompletion, false);
                    }
                    else
                    {
                        LogWarn("[Menu] Export reset failed: " + err);
                        Messages.Message("Export の初期化に失敗しました。ログを確認してください。", MessageTypeDefOf.RejectInput, false);
                    }
                });
            }

            if (DrawButton(ls, "セッションキャッシュをクリア",
                "起動中の二重書き込み防止キャッシュ（メモリ上）を初期化します。ファイル（Export/*）には触れません。"))
            {
                TranslatorHub.ClearSessionCaches(out var pm, out var ag);
                Messages.Message($"セッションキャッシュをクリアしました（perMod {pm} / aggregate {ag}）。", MessageTypeDefOf.NeutralEvent, false);
            }

            if (DrawButton(ls, "ログをクリア",
                "RimLex.log を空にして再初期化します。以後のログが見やすくなります。"))
            {
                TryMenuAction("Log clear", () =>
                {
                    try { _log?.Flush(); _log?.Dispose(); } catch { }
                    _log = null;

                    var logPath = _cfg.LogPath;
                    Directory.CreateDirectory(Path.GetDirectoryName(logPath) ?? ModDir);
                    using (var fs = new FileStream(logPath, FileMode.Create, FileAccess.Write, FileShare.Read))
                    using (var sw = new StreamWriter(fs, new System.Text.UTF8Encoding(false)))
                        sw.WriteLine("[" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "] [INFO] log cleared.");

                    _log = new System.IO.StreamWriter(logPath, true, new System.Text.UTF8Encoding(false)) { AutoFlush = true };
                    Messages.Message("ログをクリアしました。", MessageTypeDefOf.NeutralEvent, false);
                    LogInfo("[Menu] Log cleared.");
                });
            }

            ls.GapLine();

            if (DrawButton(ls, "辞書を再読み込み", "Dict/strings_ja.tsv を再読み込みして、翻訳を即時反映します。"))
            {
                TryMenuAction("Reload dict", () =>
                {
                    TranslatorHub.ReloadDictionary();
                    Messages.Message($"辞書を再読み込みしました（{TranslatorHub.DictionaryEntryCount} 行）。", MessageTypeDefOf.TaskCompletion, false);
                });
            }

            if (DrawButton(ls, "動作確認", "Export/SelfTest に “Hello from RimLex self-test” を書き出します。"))
            {
                TryMenuAction("SelfTest", () =>
                {
                    Directory.CreateDirectory(_cfg.ExportRoot);
                    string dir = Path.Combine(_cfg.ExportRoot, "SelfTest");
                    Directory.CreateDirectory(dir);

                    File.AppendAllText(Path.Combine(dir, "texts_en.txt"),
                        "Hello from RimLex self-test\n", new System.Text.UTF8Encoding(false));

                    string tsv = Path.Combine(dir, "strings_en.tsv");
                    if (!File.Exists(tsv))
                        File.WriteAllText(tsv, "timestamp_utc\tmod\tsource\tscope\ttext\n", new System.Text.UTF8Encoding(false));
                    File.AppendAllText(tsv,
                        DateTime.UtcNow.ToString("O") + "\tSelfTest\tMenu\tHello from RimLex self-test\n",
                        new System.Text.UTF8Encoding(false));

                    LogInfo("[SelfTest] Export write OK: " + dir);
                    Messages.Message("テスト出力に成功しました。Export/SelfTest を確認してください。", MessageTypeDefOf.TaskCompletion, false);
                });
            }

            ls.End();
        }

        // ---- UI helpers ----
        private static void CheckboxWithTip(Listing_Standard ls, string label, string tip, ref bool value)
        {
            Rect r = ls.GetRect(Text.LineHeight);
            bool v = value;
            Widgets.CheckboxLabeled(r, label, ref v);
            TooltipHandler.TipRegion(r, tip);
            value = v;
        }

        private static bool DrawButton(Listing_Standard ls, string label, string tip)
        {
            Rect r = ls.GetRect(30f);
            bool clicked = Widgets.ButtonText(r, label);
            TooltipHandler.TipRegion(r, tip);
            return clicked;
        }

        private static void DrawEnumDropdown(Listing_Standard ls, string label, string tip, string[] choices, string currentValue, Action<string> setValue)
        {
            Rect r = ls.GetRect(30f);
            Widgets.Label(r.LeftHalf(), label + "： " + currentValue);
            if (Widgets.ButtonText(r.RightHalf(), "変更"))
            {
                var options = new System.Collections.Generic.List<FloatMenuOption>();
                foreach (var c in choices) options.Add(new FloatMenuOption(c, () => setValue(c)));
                Find.WindowStack.Add(new FloatMenu(options));
            }
            TooltipHandler.TipRegion(r, tip);
        }

        private void TryMenuAction(string name, Action action)
        {
            try
            {
                action();
                TranslatorHub.GetAndResetSessionStats(out var rep, out var col, out var err);
                LogInfo("[Menu] " + name + $" done. replaced={rep}, collected={col}, ioErrors={err}");
            }
            catch (Exception ex)
            {
                LogWarn("[Menu] " + name + " failed: " + ex);
                Messages.Message(name + " に失敗しました。詳細はログ参照。", MessageTypeDefOf.RejectInput, false);
            }
        }

        private static void OpenFolder(string path)
        {
            try
            {
                Directory.CreateDirectory(path);
                Application.OpenURL("file:///" + path.Replace('\\', '/'));
            }
            catch (Exception ex)
            {
                LogWarn("OpenFolder failed: " + ex.Message);
            }
        }

        // ---- ログ ----
        public static void LogInfo(string msg)
        {
            try { _log?.WriteLine("[" + DateTime.Now.ToString("HH:mm:ss") + "] [INFO] " + msg); } catch { }
            try { Log.Message("[RimLex] " + msg); } catch { }
        }

        public static void LogWarn(string msg)
        {
            try { _log?.WriteLine("[" + DateTime.Now.ToString("HH:mm:ss") + "] [WARN] " + msg); } catch { }
            try { Log.Warning("[RimLex] " + msg); } catch { }
        }
    }
}

============================================================
■ About/About.xml（参考）
============================================================
<?xml version="1.0" encoding="UTF-8"?>
<ModMetaData>
  <name>RimLex - UI Text Localizer</name>
  <packageId>com.rimlex</packageId>
  <author>RimLex Project</author>
  <modClass>RimLex.ModInitializer</modClass>
  <supportedVersions>
    <li>1.5</li>
    <li>1.6</li>
  </supportedVersions>
  <description>
    ゲーム内のUI文字列を収集し、辞書（strings_ja.tsv）でリアルタイムに日本語へ置き換えます。
  </description>
</ModMetaData>

============================================================
■ RimLex.ini（テンプレート）
============================================================
# RimLex.ini（UTF-8, BOMなし）
ApplyDictAtRuntime=true
DictPath=%ModDir%/Dict/strings_ja.tsv
ExportRoot=%ModDir%/Export
ExportPerMod=true
EmitAggregate=true
ExportMode=Both
PerModSubdir=PerMod
MinLength=2
ExcludePatterns=^\s*$|^https?://|^[0-9]+$|^\d+(\.\d+)+$|^[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$|^\p{Zs}+$|^\p{Cc}+$|
LogPath=%ModDir%/RimLex.log

-- END OF SOURCE ARCHIVE --

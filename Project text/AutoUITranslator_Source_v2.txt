AutoUITranslator_Source_v2.txt
=================================
作成日: 2025-10-05 (JST)
このファイルは、AutoUITranslator の「ソース一式＋運用情報」をひとつにまとめた“完全アーカイブ”です。
チャット引き継ぎ用に、この1ファイルだけを次のスレッドへ渡せば開発を継続できます。

【重要な注記 / ビルド状態】
- この v2 は「設計と構成の更新」を含む **プレリリース（設計更新版）** です。
- 下記の「v2で追加される予定の機能」は、まだ C# 実装が一部未反映です。
- いま埋め込んでいる C# コード群は **v1実装（動作確認済み）をそのまま収録** しています。
- そのため、このファイルのままでは v1相当のDLLはビルド成功、v2新機能は未実装または未検証です。
- えーいちは Visual Studio でビルド → DLL をゲームに配置 → 実機検証 → ログ提供、の役割。GPTは差分実装・修正を担当。

----------------------------------------
■ 0) フォルダ構成（推奨）
----------------------------------------
<ModRoot>/
  ├─ About/
  │   └─ About.xml                 … MODメタ情報
  ├─ Assemblies/
  │   └─ AutoUITranslator.dll      … ビルド成果物（Release）
  ├─ Source/                        … C# プロジェクト一式（開発用）
  │   ├─ AutoUITranslator.csproj
  │   ├─ Main.cs / ModInitializer.cs
  │   ├─ Config.cs
  │   ├─ Normalizer.cs
  │   ├─ NoiseFilter.cs
  │   ├─ TranslatorHub.cs
  │   ├─ UIPatches.cs
  │   ├─ MenuUI.cs                  … v2で追加（未実装の場合はプレースホルダ）
  │   └─ UTFBuilder.cs             … 任意拡張（未実装ならプレースホルダ）
  ├─ Dict/
  │   ├─ strings_ja.tsv            … 「英語<TAB>日本語」
  │   └─ overrides/                … 同文異訳の例外（任意）
  ├─ Export/                        … 収集出力（ゲーム実行時に生成）
  │   ├─ _All/                     … 集約版（v2）
  │   └─ <ModName>/                … MOD別出力（v2）
  ├─ Build/
  │   └─ UTF/                      … 任意：UTF連携の子MOD出力先（拡張）
  └─ AutoUITranslator.ini          … 設定ファイル（下記テンプレート）

----------------------------------------
■ 1) AutoUITranslator.ini（テンプレート / 既定値の例）
----------------------------------------
; 文字コードは UTF-8 (BOMなし) 推奨
[General]
ApplyDictAtRuntime=true
DictPath=Dict/strings_ja.tsv
ExportRoot=Export
ExportPerMod=true
EmitAggregate=true
MinLength=2
; 正規表現は '|' 区切りで並記
ExcludePatterns=^\s*$|^https?://|^[0-9]+$

[Advanced]
LogPath=AutoUITranslator.log
; フックの有効・無効（必要に応じて切替）
Hook.WidgetsLabel=true
Hook.ListingLabel=true
Hook.Tooltip=true
Hook.ButtonText=true
Hook.Slider=true
Hook.FloatMenu=true
Hook.Gizmo=true
Hook.Dialog=true
Hook.GUILabel=true

[UTFBuilder]  ; 任意拡張
Enable=false
UTFOutRoot=Build/UTF

----------------------------------------
■ 2) v2で追加される予定の機能（設計反映 / 実装はこれから）
----------------------------------------
- 収集の時点で MOD 別に自動分類（Export/<ModName>/…）し、
  さらに _All/ に集約版（ソート・重複排除・未訳抽出）を生成
- Mod設定メニュー（MenuUI）から：
  「辞書再読み込み / 未訳抽出 / 整理（MOD別＋集約）/（任意）UTF XML生成」
- 追加フック：スライダー/レンジ、フロートメニュー、ギズモ、ダイアログ、GUI.Label
- 同文異訳のオーバーライド（overrides ディレクトリ運用）
- （任意拡張）caller 情報の収集と UTF 子MODの自動出力

※ この“v2予定機能”は **未ビルド・未検証**。v1コードに差分実装を加え、段階的にDLL化して検証予定。

----------------------------------------
■ 3) ビルド手順（要点）
----------------------------------------
- 推奨環境: Visual Studio 2022 / .NET Framework 4.7.2〜4.8 / Harmony 2.x
- 参照設定:
  - RimWorld\RimWorldWin64_Data\Managed\Assembly-CSharp.dll
  - RimWorld\RimWorldWin64_Data\Managed\UnityEngine*.dll（必要なもの）
  - HarmonyLib.dll（MOD同梱 or NuGet）
- ビルド構成: Release / x64 推奨（環境に合わせて）
- 出力: Assemblies/AutoUITranslator.dll に配置
- 配置後: RimWorld起動 → Modリストで有効化 → 設定UIで挙動確認

----------------------------------------
■ 4) 次のチャットへの引き継ぎガイド
----------------------------------------
1) このファイル（AutoUITranslator_Source_v2.txt）と、機能書（AutoUITranslator_FunctionalSpec_v2.txt）を同時にアップロード
2) GPTへの依頼文テンプレート：
   「機能書v2を基準に、このv2ソースまとめ内のv1コードを差分改修して、
     Per-Mod出力・集約生成・MenuUI・追加フックの実装を行って。
     ビルドエラーが出ないようにクラス骨格から提示し、足りない部分は逐次補う。」
3) えーいちは DLL をビルド → 実機テスト → ログ/エラーを報告

----------------------------------------
■ 5) 変更履歴（ハイライト）
----------------------------------------
- v2（設計更新版/プレリリース）:
  - UTF依存を外し、AutoUITranslator単独運用を正式化
  - 収集のPer-Mod分類＋集約出力の方針を仕様化
  - Mod設定メニューでの運用オペレーションを仕様化
  - 追加フックの対象を一覧化

- v1（動作確認済み）:
  - 収集＆辞書反映の中核ロジック
  - Widgets.Label / Listing_Standard.Label / TooltipHandler など基礎フック

----------------------------------------
■ 6) ソースコード群（v1現行・動作確認済みをそのまま収録）
----------------------------------------
以下は、既存の v1 ソースまとめをそのまま埋め込んでいます。
この部分は「ビルド済みで動作確認された実装」です。v2機能は今後ここに追記・改修していきます。

----- ▼▼▼ ここから v1 原文そのまま ▼▼▼ -----
AutoUITranslator – ソースコード一式 (v1)
====================================

このファイルには、AutoUITranslator の **全ソースコード** と最小ビルド設定が含まれます。
そのまま貼り付け/保存して使えるように、ファイルごとに区切って記載しています。

推奨ターゲット: .NET Framework 4.8（C# 7.3）
※ 4.7.2 でも動作可。開発環境に合わせて .csproj の <TargetFrameworkVersion> を変更してください。

プロジェクト構成（例）
----------------------
AutoUITranslator_DLL_Source\
  AutoUITranslator.csproj
  Config.cs
  NoiseFilter.cs
  TranslatorHub.cs
  UIPatches.cs
  ModInitializer.cs
  About\About.xml
  AutoUITranslator.ini   （サンプル）

事前準備（参照パス）
--------------------
環境変数 RIMWORLD_MANAGED を RimWorld の Managed フォルダに設定しておくと参照解決が楽です。
例: D:\Steam\steamapps\common\RimWorld\RimWorldWin64_Data\Managed

============================================================
ファイル: AutoUITranslator.csproj
============================================================
```xml
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A6E0E850-2B6E-4A65-9A27-6A06B87A3B72}</ProjectGuid>
    <OutputType>Library</OutputType>
    <RootNamespace>AutoUITranslator</RootNamespace>
    <AssemblyName>AutoUITranslator</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <TargetFrameworkProfile></TargetFrameworkProfile>
    <LangVersion>7.3</LangVersion>
    <Deterministic>false</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
    <Reference Include="Assembly-CSharp">
      <HintPath>$(RIMWORLD_MANAGED)\Assembly-CSharp.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>$(RIMWORLD_MANAGED)\UnityEngine.CoreModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>$(RIMWORLD_MANAGED)\UnityEngine.IMGUIModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="0Harmony">
      <HintPath>$(RIMWORLD_MANAGED)\0Harmony.dll</HintPath>
      <Private>false</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Config.cs" />
    <Compile Include="NoiseFilter.cs" />
    <Compile Include="TranslatorHub.cs" />
    <Compile Include="UIPatches.cs" />
    <Compile Include="ModInitializer.cs" />
  </ItemGroup>
</Project>
```

============================================================
ファイル: Config.cs
============================================================
```csharp
using System;
using System.IO;
using System.Text;

namespace AutoUITranslator
{
    public sealed class Config
    {
        public string ExportTsv;
        public string ExportText;
        public string DictTsv;
        public int MinLength = 2;
        public string ExportMode = "Both";
        public bool ApplyDictAtRuntime = false; // 即時置換のON/OFF（既定: false）

        public string[] ExcludePatterns = new string[]
        {
            @"^\s*$",
            @"^\d+(\.\d+)?$",
            @"^v?\d+(\.\d+){1,}$",
            @"^https?://",
            @"^[0-9A-Fa-f]{8}(?:-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$",
            @"^[A-Z]{2,}(?:_[A-Z0-9]{2,})+$",
            @"^\p{Zs}+$|^\p{Cc}+$",
            @"^(?:[\p{IsCJKUnifiedIdeographs}\p{IsHiragana}\p{IsKatakana}\p{P}\p{Zs}]+)$"
        };

        public static Config Load(string path, string modDir, string defaultExport, string defaultDict)
        {
            Config cfg = new Config();
            cfg.ExportTsv = defaultExport;
            cfg.ExportText = Path.Combine(modDir, "Export", "texts_en.txt");
            cfg.DictTsv = defaultDict;

            if (!File.Exists(path)) return cfg;

            string[] lines = File.ReadAllLines(path, Encoding.UTF8);
            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i].Trim();
                if (line.Length == 0 || line.StartsWith("#") || line.StartsWith(";")) continue;
                int idx = line.IndexOf('=');
                if (idx <= 0) continue;

                string key = line.Substring(0, idx).Trim();
                string val = line.Substring(idx + 1).Trim();

                Func<string, string> expand = delegate (string v)
                {
                    string r = v.Replace("%ModDir%", modDir.Replace("\\", "/"));
                    r = r.Replace("/", Path.DirectorySeparatorChar.ToString());
                    return r;
                };

                switch (key.ToLowerInvariant())
                {
                    case "exportpath":
                        cfg.ExportTsv = expand(val); break;
                    case "exporttextpath":
                        cfg.ExportText = expand(val); break;
                    case "dictpath":
                        cfg.DictTsv = expand(val); break;
                    case "minlength":
                        int n;
                        if (int.TryParse(val, out n)) cfg.MinLength = Math.Max(1, n); break;
                    case "excludepatterns":
                        cfg.ExcludePatterns = val.Split(new[] { '|' }, StringSplitOptions.RemoveEmptyEntries);
                        break;
                    case "exportmode":
                        string m = val.Trim();
                        if (string.Equals(m, "full", StringComparison.OrdinalIgnoreCase) ||
                            string.Equals(m, "textonly", StringComparison.OrdinalIgnoreCase) ||
                            string.Equals(m, "both", StringComparison.OrdinalIgnoreCase))
                            cfg.ExportMode = m;
                        break;
                    case "applydictatruntime":
                        bool b;
                        if (bool.TryParse(val, out b)) cfg.ApplyDictAtRuntime = b;
                        break;
                }
            }
            return cfg;
        }
    }
}
```

============================================================
ファイル: NoiseFilter.cs
============================================================
```csharp
using System.Text.RegularExpressions;

namespace AutoUITranslator
{
    public static class NoiseFilter
    {
        private static int _minLen = 2;
        private static Regex[] _rx;

        public static void Init(Config cfg)
        {
            _minLen = cfg.MinLength > 0 ? cfg.MinLength : 2;
            _rx = new Regex[cfg.ExcludePatterns.Length];
            for (int i = 0; i < cfg.ExcludePatterns.Length; i++)
            {
                _rx[i] = new Regex(cfg.ExcludePatterns[i], RegexOptions.IgnoreCase | RegexOptions.Compiled);
            }
        }

        public static bool IsNoise(string s)
        {
            if (string.IsNullOrEmpty(s)) return true;
            if (s.Length < _minLen) return true;
            for (int i = 0; i < _rx.Length; i++)
            {
                if (_rx[i].IsMatch(s)) return true;
            }
            return false;
        }
    }
}
```

============================================================
ファイル: TranslatorHub.cs
============================================================
```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace AutoUITranslator
{
    public static class TranslatorHub
    {
        private static readonly Dictionary<string, string> _ja =
            new Dictionary<string, string>(StringComparer.Ordinal);
        private static readonly HashSet<string> _enrolled =
            new HashSet<string>(StringComparer.Ordinal);

        private static Action<string> _logInfo = delegate { };
        private static Action<string> _logWarn = delegate { };

        private static string _exportTsv = string.Empty;
        private static string _exportText = string.Empty;
        private static string _dictPath = string.Empty;
        private static string _exportMode = "Both";

        private static readonly Regex RxRichTags =
            new Regex(@"<\/?color(=[^>]*)?>|<\/?size(=[^>]*)?>|<\/?b>|<\/?i>|<\/?u>",
                      RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly Regex RxCtrl =
            new Regex(@"[\u0000-\u001F]", RegexOptions.Compiled);
        private static readonly Regex RxMultiSpace =
            new Regex(@"\s{2,}", RegexOptions.Compiled);

        public static void InitIO(
            string dictTsv,
            string exportTsv,
            string exportText,
            string exportMode,
            Action<string> logInfo,
            Action<string> logWarn)
        {
            _logInfo = (logInfo != null) ? logInfo : (delegate { });
            _logWarn = (logWarn != null) ? logWarn : (delegate { });

            _dictPath = (dictTsv ?? string.Empty);
            _exportTsv = (exportTsv ?? string.Empty);
            _exportText = (exportText ?? string.Empty);
            _exportMode = string.IsNullOrEmpty(exportMode) ? "Both" : exportMode;

            // 辞書読み込み
            _ja.Clear();
            try
            {
                if (File.Exists(_dictPath))
                {
                    string[] lines = File.ReadAllLines(_dictPath, Encoding.UTF8);
                    for (int i = 0; i < lines.Length; i++)
                    {
                        string line = lines[i];
                        if (string.IsNullOrWhiteSpace(line)) continue;
                        string[] sp = line.Split('\t');
                        if (sp.Length >= 2)
                        {
                            string en = Normalize(sp[0]);
                            string ja = sp[1].Trim();
                            if (!_ja.ContainsKey(en)) _ja[en] = ja;
                        }
                    }
                    _logInfo("Dict loaded: " + _ja.Count + " entries.");
                }
                else
                {
                    _logInfo("Dict not found (will create on save).");
                }
            }
            catch (Exception ex)
            {
                _logWarn("Dict load failed: " + ex.Message);
            }

            // 既知キャッシュを TSV/TXT からシード
            _enrolled.Clear();
            int seeded = 0;
            try
            {
                if (!string.IsNullOrEmpty(_exportTsv) && File.Exists(_exportTsv))
                {
                    string[] lines = File.ReadAllLines(_exportTsv, Encoding.UTF8);
                    for (int i = 0; i < lines.Length; i++)
                    {
                        string line = lines[i];
                        int idx = line.LastIndexOf('\t');
                        if (idx >= 0 && idx + 1 < line.Length)
                        {
                            string en = line.Substring(idx + 1);
                            if (_enrolled.Add(en)) seeded++;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logWarn("Seed from TSV failed: " + ex.Message);
            }

            try
            {
                if (!string.IsNullOrEmpty(_exportText) && File.Exists(_exportText))
                {
                    string[] lines = File.ReadAllLines(_exportText, Encoding.UTF8);
                    for (int i = 0; i < lines.Length; i++)
                    {
                        string en = lines[i].Trim();
                        if (en.Length == 0) continue;
                        if (_enrolled.Add(en)) seeded++;
                    }
                }
            }
            catch (Exception ex)
            {
                _logWarn("Seed from Text failed: " + ex.Message);
            }

            if (string.Equals(_exportMode, "Full", StringComparison.OrdinalIgnoreCase) ||
                string.Equals(_exportMode, "Both", StringComparison.OrdinalIgnoreCase))
            {
                EnsureTsvHeader();
            }

            _logInfo("Export cache: " + _enrolled.Count + " collected (seed +" + seeded + ").");
        }

        public static string TranslateOrEnroll(string text, string scope, string source)
        {
            if (string.IsNullOrWhiteSpace(text)) return text;

            string norm = Normalize(text);
            string ja;
            if (_ja.TryGetValue(norm, out ja))
                return ja;

            if (NoiseFilter.IsNoise(norm))
                return text;

            Enroll(norm, scope, source);
            return text;
        }

        private static void Enroll(string en, string scope, string source)
        {
            try
            {
                lock (_enrolled)
                {
                    if (_enrolled.Contains(en)) return;

                    if (!string.IsNullOrEmpty(_exportTsv))
                    {
                        string dirTsv = Path.GetDirectoryName(_exportTsv);
                        if (!string.IsNullOrEmpty(dirTsv)) Directory.CreateDirectory(dirTsv);
                    }
                    if (!string.IsNullOrEmpty(_exportText))
                    {
                        string dirTxt = Path.GetDirectoryName(_exportText);
                        if (!string.IsNullOrEmpty(dirTxt)) Directory.CreateDirectory(dirTxt);
                    }

                    UTF8Encoding utf8NoBom = new UTF8Encoding(false);

                    if (string.Equals(_exportMode, "Full", StringComparison.OrdinalIgnoreCase) ||
                        string.Equals(_exportMode, "Both", StringComparison.OrdinalIgnoreCase))
                    {
                        EnsureTsvHeader();
                        string line = string.Format("{0}\t{1}\t{2}\t{3}",
                            DateTime.UtcNow.ToString("O"), source ?? string.Empty, scope ?? string.Empty, en);
                        File.AppendAllText(_exportTsv, line + Environment.NewLine, utf8NoBom);
                    }

                    if (string.Equals(_exportMode, "TextOnly", StringComparison.OrdinalIgnoreCase) ||
                        string.Equals(_exportMode, "Both", StringComparison.OrdinalIgnoreCase))
                    {
                        File.AppendAllText(_exportText, en + Environment.NewLine, utf8NoBom);
                    }

                    _enrolled.Add(en);
                }
            }
            catch (Exception ex)
            {
                _logWarn("Enroll failed: " + ex.Message);
            }
        }

        private static void EnsureTsvHeader()
        {
            try
            {
                if (string.IsNullOrEmpty(_exportTsv)) return;

                if (!File.Exists(_exportTsv))
                {
                    string dir = Path.GetDirectoryName(_exportTsv);
                    if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
                    string header = "timestamp_utc\tsource\tscope\ttext";
                    File.WriteAllText(_exportTsv, header + Environment.NewLine, new UTF8Encoding(false));
                }
                else
                {
                    FileInfo fi = new FileInfo(_exportTsv);
                    if (fi.Length == 0)
                    {
                        string header = "timestamp_utc\tsource\tscope\ttext";
                        File.WriteAllText(_exportTsv, header + Environment.NewLine, new UTF8Encoding(false));
                    }
                }
            }
            catch (Exception ex)
            {
                _logWarn("Header write failed: " + ex.Message);
            }
        }

        private static string Normalize(string s)
        {
            if (string.IsNullOrEmpty(s)) return string.Empty;
            string t = s.Replace("\r\n", "\n").Replace("\r", "\n");
            t = RxRichTags.Replace(t, string.Empty);
            t = RxCtrl.Replace(t, string.Empty);
            t = t.Replace('\n', ' ');
            t = RxMultiSpace.Replace(t, " ");
            return t.Trim();
        }
    }
}
```

============================================================
ファイル: UIPatches.cs
============================================================
```csharp
using HarmonyLib;
using RimWorld;
using UnityEngine;
using Verse;

namespace AutoUITranslator
{
    public static class UIPatches
    {
        private static bool _applyAtRuntime = false; // ini で制御

        public static void Apply(Harmony harmony, System.Action<string> logInfo, System.Action<string> logWarn, bool applyAtRuntime)
        {
            _applyAtRuntime = applyAtRuntime;

            // Widgets.Label(Rect, string)
            harmony.Patch(
                AccessTools.Method(typeof(Widgets), nameof(Widgets.Label), new System.Type[] { typeof(Rect), typeof(string) }),
                prefix: new HarmonyMethod(typeof(UIPatches), nameof(Widgets_Label_Prefix)));

            // Listing_Standard.Label(string, float)
            harmony.Patch(
                AccessTools.Method(typeof(Listing_Standard), nameof(Listing_Standard.Label), new System.Type[] { typeof(string), typeof(float) }),
                prefix: new HarmonyMethod(typeof(UIPatches), nameof(Listing_Label_Prefix)));

            // Tooltip（TipSignal）
            harmony.Patch(
                AccessTools.Method(typeof(TooltipHandler), nameof(TooltipHandler.TipRegion), new System.Type[] { typeof(Rect), typeof(TipSignal) }),
                prefix: new HarmonyMethod(typeof(UIPatches), nameof(Tooltip_Prefix)));

            // （任意）ボタン文字列。即時プレビュー時だけ差し替えが効く
            harmony.Patch(
                AccessTools.Method(typeof(Widgets), nameof(Widgets.ButtonText),
                    new System.Type[]{ typeof(Rect), typeof(string), typeof(bool), typeof(bool), typeof(bool), typeof(bool)}),
                prefix: new HarmonyMethod(typeof(UIPatches), nameof(ButtonText_Prefix)));

            logInfo("UIPatches applied. ApplyDictAtRuntime=" + _applyAtRuntime);
        }

        public static bool Widgets_Label_Prefix(Rect rect, ref string label)
        {
            if (string.IsNullOrEmpty(label)) return true;
            string ja = TranslatorHub.TranslateOrEnroll(label, "Widgets.Label", "UI");
            if (_applyAtRuntime) label = ja;
            return true;
        }

        public static bool Listing_Label_Prefix(Listing_Standard __instance, ref string label, float height = -1f)
        {
            if (string.IsNullOrEmpty(label)) return true;
            string ja = TranslatorHub.TranslateOrEnroll(label, "Listing_Standard.Label", "UI");
            if (_applyAtRuntime) label = ja;
            return true;
        }

        public static bool Tooltip_Prefix(Rect rect, ref TipSignal tip)
        {
            if (tip.text != null)
            {
                string txt = tip.text;
                if (!string.IsNullOrEmpty(txt))
                {
                    string ja = TranslatorHub.TranslateOrEnroll(txt, "TooltipHandler.TipRegion", "Tooltip");
                    if (_applyAtRuntime) tip = new TipSignal(ja, tip.delay);
                }
            }
            return true;
        }

        public static bool ButtonText_Prefix(Rect rect, ref string label, bool drawBackground, bool doMouseoverSound, bool active, bool drawHighlight)
        {
            if (string.IsNullOrEmpty(label)) return true;
            string ja = TranslatorHub.TranslateOrEnroll(label, "Widgets.ButtonText", "UI");
            if (_applyAtRuntime) label = ja;
            return true;
        }
    }
}
```

============================================================
ファイル: ModInitializer.cs
============================================================
```csharp
using System;
using System.IO;
using HarmonyLib;
using Verse;

namespace AutoUITranslator
{
    public class ModInitializer : Mod
    {
        public static readonly string ModId = "com.autouitranslator";
        public static string ModDir;
        public static string LogPath;
        private static System.IO.StreamWriter _log;

        public ModInitializer(ModContentPack content) : base(content)
        {
            try
            {
                ModDir = content.RootDir;

                Directory.CreateDirectory(Path.Combine(ModDir, "Export"));
                Directory.CreateDirectory(Path.Combine(ModDir, "Dict"));

                LogPath = Path.Combine(ModDir, "AutoUITranslator.log");
                _log = new System.IO.StreamWriter(LogPath, append: true, new System.Text.UTF8Encoding(false));
                _log.AutoFlush = true;

                LogInfo("AutoUITranslator initializing...");

                string ini = Path.Combine(ModDir, "AutoUITranslator.ini");
                string defaultExport = Path.Combine(ModDir, "Export", "strings_en.tsv");
                string defaultDict = Path.Combine(ModDir, "Dict", "strings_ja.tsv");
                Config cfg = Config.Load(ini, ModDir, defaultExport, defaultDict);

                NoiseFilter.Init(cfg);
                TranslatorHub.InitIO(cfg.DictTsv, cfg.ExportTsv, cfg.ExportText, cfg.ExportMode, LogInfo, LogWarn);

                Harmony harmony = new Harmony(ModId);
                UIPatches.Apply(harmony, LogInfo, LogWarn, cfg.ApplyDictAtRuntime);

                LogInfo("ExportMode=" + cfg.ExportMode + ", ExportTsv=" + cfg.ExportTsv + ", ExportText=" + cfg.ExportText);
                LogInfo("ApplyDictAtRuntime=" + cfg.ApplyDictAtRuntime);
                LogInfo("AutoUITranslator initialized.");
            }
            catch (Exception ex)
            {
                LogWarn("Initialization error: " + ex);
            }
        }

        public static void LogInfo(string msg) { Write("INFO", msg); }
        public static void LogWarn(string msg) { Write("WARN", msg); }

        private static void Write(string level, string msg)
        {
            try
            {
                if (_log != null)
                {
                    _log.WriteLine("[" + DateTime.Now.ToString("HH:mm:ss") + "] [" + level + "] " + msg);
                }
            }
            catch { }
        }
    }
}
```

============================================================
ファイル: About/About.xml
============================================================
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ModMetaData>
  <name>AutoUITranslator</name>
  <packageId>com.autouitranslator</packageId>
  <author>AutoUITranslator Project</author>

  <!-- 必須：Modの入口 -->
  <modClass>AutoUITranslator.ModInitializer</modClass>

  <supportedVersions>
    <li>1.5</li>
    <li>1.6</li>
  </supportedVersions>

  <description>
    ゲーム内UIテキスト（ラベル、チェックボックス、ツールチップ）を自動採集し、
    Dict/strings_ja.tsv の手動辞書で置き換えます。
    Universal Translation Framework と併用して自然な日本語化を行います。
    - 収集: Export/strings_en.tsv（起動後に自動生成）
    - 辞書: Dict/strings_ja.tsv（UTF-8、タブ区切り）
  </description>
</ModMetaData>
```

============================================================
ファイル: AutoUITranslator.ini（サンプル）
============================================================
```ini
# AutoUITranslator.ini
# %ModDir% はこのMODフォルダのパスに展開されます。

# 4列TSV（デバッグ向け）と本文だけの双方を出力
ExportMode=Both
ExportPath=%ModDir%/Export/strings_en.tsv
ExportTextPath=%ModDir%/Export/texts_en.txt

# UTFが読む辞書
DictPath=%ModDir%/Dict/strings_ja.tsv

# 収集する最小長（短すぎるとノイズが増える。必要なら 1〜3 で調整）
MinLength=2

# 除外パターン（正規表現、| で連結）
# 空行 / 数字のみ / バージョン番号 / URL / GUID / 定数っぽいID / 空白や制御文字だけ / 「日本語のみ」の行
ExcludePatterns=^\s*$|^\d+(\.\d+)?$|^v?\d+(\.\d+){1,}$|^https?://|^[0-9A-Fa-f]{8}(?:-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$|^[A-Z]{2,}(?:_[A-Z0-9]{2,})+$|^\p{Zs}+$|^\p{Cc}+$|^(?:[\p{IsCJKUnifiedIdeographs}\p{IsHiragana}\p{IsKatakana}\p{P}\p{Zs}]+)$
```

============================================================
ビルド補足
--------
1) Visual Studio でソリューション/プロジェクトを作成し、上記ファイルを追加。
2) プロパティ → 対象フレームワークを「.NET Framework 4.8」に設定（4.7.2 でも可）。
3) 参照に 0Harmony.dll / Assembly-CSharp.dll / UnityEngine.CoreModule.dll / UnityEngine.IMGUIModule.dll を追加。
   （RIMWORLD_MANAGED 環境変数を使うと .csproj の HintPath がそのまま通ります）
4) Release / Any CPU でビルド → `bin\Release\AutoUITranslator.dll` を MOD の `Assemblies` へ配置。

以上。

----- ▲▲▲ ここまで v1 原文そのまま ▲▲▲ -----
